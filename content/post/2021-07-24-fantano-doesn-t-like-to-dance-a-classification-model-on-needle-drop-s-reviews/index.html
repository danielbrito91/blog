---
title: 'Fantano doesn’t like to dance: a classification model on Needle Drop’s reviews'
author: Daniel Brito
date: '2021-07-25'
cover:
        image: "https://lastfm.freetls.fastly.net/i/u/770x0/63dce6a777fc491b8c317542037bd15d.webp#63dce6a777fc491b8c317542037bd15d"
        alt: ""
        caption: "Image from [Last FM](https://www.last.fm/pt/music/Anthony+Fantano)"
        relative: false 
ShowToc: true
ShowBreadCrumbs: true
slug: []
categories:
  - R
  - python
tags:
  - scikit-learn
  - classification
  - ggplot2
  - extra-trees
  - ice
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>
<script src="{{< blogdown/postref >}}index_files/core-js/shim.min.js"></script>
<script src="{{< blogdown/postref >}}index_files/react/react.min.js"></script>
<script src="{{< blogdown/postref >}}index_files/react/react-dom.min.js"></script>
<script src="{{< blogdown/postref >}}index_files/reactwidget/react-tools.js"></script>
<script src="{{< blogdown/postref >}}index_files/htmlwidgets/htmlwidgets.js"></script>
<script src="{{< blogdown/postref >}}index_files/reactable-binding/reactable.js"></script>


<p>Anthony Fantano (<span class="citation">@theneedledrop</span>, a.k.a Melon) has been reviewing albums on his <a href="https://www.youtube.com/c/theneedledrop/videos">YouTube channel</a> for more than one decade. I’ve been enjoying his work and discovering some great music since 2014.</p>
<p>Recently, I was wondering if I could fit a classification model to predict if an album would get a high score from Fantano. Besides, I wanted to understand what features drive his scoring. Surprisingly, I found that danceability isn’t a feature that Melon appreciates.</p>
<p>Using Python and R, I got the audio features of the albums from Spotify using <code>spotipy</code>, cleaned the data in R, fitted and evaluated a predictive model with Scikit-Learn. The whole process is described in this post.</p>
<hr />
<div id="getting-the-data" class="section level1">
<h1>Getting the data</h1>
<p>I grabbed data from the Needle Drop reviews and from the albums’ audio features from Spotify API. First, let’s load the packages in R.</p>
<pre class="r"><code>#data cleaning and reading
library(tidyverse)
library(lubridate)
library(googlesheets4)
library(reticulate)
use_condaenv(&quot;py3.8&quot;, required = TRUE)

#dataviz
library(reactable)
library(hrbrthemes)
library(glue)
library(ggtext)
library(ggdist)
library(gghalves)
library(patchwork)</code></pre>
<div id="reviews" class="section level2">
<h2>Reviews</h2>
<p>Part of the dataset containing the relation of reviews and its scores came from <a href="https://www.kaggle.com/jaredarcilla/anthony-fantano-reviews?select=fantano_reviews.csv">Jared Arcilla’s Kaggle dataset</a> and by one <a href="https://www.reddit.com/r/fantanoforever/comments/c11z5m/google_sheet_of_fantanos_reviews/">Reddit user</a> (unfortunately, the post was deleted), and later completed by me. The last video in the database is Palais d’Argile by Feu! Chatterton (posted on 2021-03-25). I searched album and artist URI from Spotify using <code>spotipy</code>. The relation of album URI, album title, artist name, artist URI, and review features (date, type, score, and link) were stored on Google Sheets.</p>
<pre class="r"><code>gs4_deauth() #the google sheet is public

reviews &lt;-
        read_sheet(&quot;https://docs.google.com/spreadsheets/d/1sei8XeqjjznXVOiBpmVWpcB366sM1MBUL5QYV7qxpzs/edit?usp=sharing&quot;, col_types = &quot;ccccccDcdcc&quot;)</code></pre>
<p>A total of 2350 album reviews were collected. The following 77 albums were not found on Spotify (3% of the reviews).</p>
<pre class="r"><code>reviews %&gt;%
        filter(is.na(album_uri)) %&gt;% 
        select(title, artist, review_date, score, word_score, link) %&gt;% 
        reactable(
                columns = list(
                        title = colDef(name = &quot;Title&quot;),
                        artist = colDef(name = &quot;Artist&quot;),
                        review_date = colDef(name = &quot;Review date&quot;),
                        score = colDef(name = &quot;Score&quot;),
                        word_score = colDef(name = &quot;Word score/observation&quot;),
                        link = colDef(name = &quot;Review link&quot;)
                ),
                highlight = TRUE, bordered = TRUE)</code></pre>
<div id="htmlwidget-1" class="reactable html-widget" style="width:auto;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"tag":{"name":"Reactable","attribs":{"data":{"title":["Cloud Cuckooland","Desert Fires","All Day","Bastard","777 Volume One","Shit Computer","Dark Country Magic","ViCKi LEEKX","Kills","After School Special","Self-Titled 7''","Returnof4eva","Exmilitary","Poor Lily","Sam Baker's Album","BBNG","Lost In Translation","I Wish My Brother Rob Was Here","Abhorrent Evolution","LiveLoveA$AP","Echoes of Silence","4evaNaDay","BBNG2","Tour Sampler CD-R","The Engine Room","NO","Eschatological Scatology","No Idols","Lord$ Never Worry","In the Middle of Infinity","Rare Chandeliers","Duality","Floral Shoppe","Widowmaker","PEEP: The aPROcalypse","The Eulogy","King Remembered In Time","Howl","Owl Pharaoh EP / MIXTAPE /","Random Access Memories Memories REMIX","My Grandmother's Basement","Endless Night","Nostalgic 64","Jimmy The Burnout","Broken Ankles","Self-Titled","The Powers That B Pt. 1 a.k.a. Niggas On The Moon","Self-Titled","No More","World Peace is None of Your Business","Mouth Sounds / Mouth Silence","Days Before Rodeo","STN MTN / Kauai MIXTAPE &","Clockwork Indigo EP","Sterilizer","I Am Your Destruction","A Special Episode Of","La Chaise-Dyable","Simple Songs","Third Side of Tape","It's Better This Way","Divers","The 2nd Amendment","Trout Mask Replica","Mouth Moods","Thin Black Duke","Godfather II","I Am Greater Than I Was","Cease & Desist","HWH7","Peaceful as Hell","God Has Nothing to Do With This Leave Him Out of It","Microphones in 2020","Mouth Dreams","Act II: The Patents of Nobility (The Turn)","Forever in Your Heart","Imperative Imperceptible Impulse"],"artist":["Various Artists","Noveller","Girl Talk","Tyler, The Creator","Tonetta","Kids & Explosions","Big Blood","M.I.A.","jj","A-1","Natural Child","Big K.R.I.T.","Death Grips","Poor Lily","Samiyam","BADBADNOTGOOD","Mr. Muthafuckin' eXquire","Milo","Oblivionized","ASAP Rocky","The Weeknd","Big K.R.I.T.","BADBADNOTGOOD","Cerce","Suns","Old Man Gloom","Gnaw Their Tongues","Domo Genesis","A$AP Mob","03:33","Action Bronson, the Alchemist","Captain Murphy","Macintosh Plus","Dragged Into Sunlight","The Progressive Era","Cakes Da Killa","Big K.R.I.T.","This Routine Is Hell","Travis Scott","Daftside","Jarren Benton","TOAD","Denzel Curry","Nocando","Girl Talk & Freeway","Pink Guy","Death Grips","Caustic Window","Shlohmo & Jeremih","Morrissey","Neil Cicierega","Travi$ Scott","Childish Gambino","Clockwork Indigo","Sterilizer","I Am Your Destruction","Open Mike Eagle","Peste Noire","Jim O'Rourke","Lil Ugly Mane","Big K.R.I.T.","Joanna Newsom","JPEGMAFIA x Freaky","Captain Beefheart","Neil Cicierega","Oxbow","Wiley","21 Savage","Blarf","Westside Gunn","Black Dresses","Backxwash","the Microphones","Neil Cicierega","Jay Electronica","Black Dresses","Ad Nauseam"],"review_date":["2010-06-28","2010-07-07","2010-11-18","2010-12-02","2010-12-05","2010-12-07","2010-12-27","2011-01-03","2011-01-05","2011-01-17","2011-02-11","2011-03-31","2011-05-05","2011-06-14","2011-07-01","2011-09-29","2011-10-12","2011-10-31","2011-11-01","2011-11-03","2012-01-04","2012-03-07","2012-04-05","2012-05-24","2012-06-15","2012-06-28","2012-07-24","2012-08-03","2012-08-30","2012-10-24","2012-11-16","2012-11-21","2012-11-28","2012-12-05","2013-01-11","2013-02-05","2013-04-15","2013-05-23","2013-05-27","2013-07-01","2013-07-02","2013-08-13","2013-09-16","2014-04-02","2014-04-14","2014-05-27","2014-06-17","2014-06-23","2014-07-22","2014-07-24","2014-07-31","2014-08-29","2014-10-14","2014-10-28","2014-11-19","2014-11-23","2015-02-06","2015-05-12","2015-05-18","2015-06-24","2015-10-22","2015-10-27","2016-08-11","2017-01-02","2017-01-25","2017-08-07","2018-05-10","2019-01-10","2019-07-11","2019-11-11","2020-05-01","2020-06-02","2020-08-17","2020-10-05","2020-10-16","2021-02-18","2021-02-24"],"score":[7,7,8,7,6,8,7,6,3,7,8,9,8,8,5,8,"NA",8,8,8,8,8,9,7,"NA",6,7,5,3,6,8,7,4,6,8,8,7,8,3,"NA","NA",7,7,6,8,"NA","NA",6,5,5,8,3,4,7,7,7,8,7,6,8,5,8,"NA","NA",9,8,5,7,"NA",5,9,8,7,4,4,8,8],"word_score":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"co-review",null,null,null,null,null,null,null,"intern review",null,null,null,null,null,null,null,null,null,null,null,null,null,null,"quick review","quick review",null,null,null,null,"burp","YET",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"quick review","classic",null,null,null,null,"burp",null,null,null,null,null,null,null,null],"link":["https://www.youtube.com/watch?v=WnoLpkdUDng","https://www.youtube.com/watch?v=EOJLDZMDS1A","https://www.youtube.com/watch?v=GMKfsj1fg5g","https://www.youtube.com/watch?v=_2RPGAA6p4E","https://www.youtube.com/watch?v=EZOQBqCPQHc","https://www.youtube.com/watch?v=nQe_rTrxGyA","https://www.youtube.com/watch?v=Uu1_BYX8ars","https://www.youtube.com/watch?v=tmgAH3ytu0Y","https://www.youtube.com/watch?v=qrq1QohxWwU","https://www.youtube.com/watch?v=X1nALCk5kMU","https://www.youtube.com/watch?v=HAaEjb9l180","https://www.youtube.com/watch?v=RG3E7xK6Oq4","https://www.youtube.com/watch?v=AZegHBU-ffQ","https://www.youtube.com/watch?v=1J2Fi3fiN7s","https://www.youtube.com/watch?v=2zmWqxEUYiE","https://www.youtube.com/watch?v=A96ENM-zcnE","https://www.youtube.com/watch?v=y38fLimjzQI","https://www.youtube.com/watch?v=1_d3YFEGeCQ","https://www.youtube.com/watch?v=8PqLOyHA7BI","https://www.youtube.com/watch?v=NHnS2gDJEPY","https://www.youtube.com/watch?v=nuRLRQl0tZ8","https://www.youtube.com/watch?v=mbmpyvyIj3A","https://www.youtube.com/watch?v=e2g9_YXxfY0","https://www.youtube.com/watch?v=V4RJ0eOZiXE","https://www.youtube.com/watch?v=hv65cRcTDes","https://www.youtube.com/watch?v=j2VypHw0AD4","https://www.youtube.com/watch?v=mVtFxatTLgU","https://www.youtube.com/watch?v=bxkMo9ECakI","https://www.youtube.com/watch?v=96slWZRmBWU","https://www.youtube.com/watch?v=zjJprluULvI","https://www.youtube.com/watch?v=1GyJexedwEU","https://www.youtube.com/watch?v=aVCMiepR6wA","https://www.youtube.com/watch?v=f0D9IyyeEEU","https://www.youtube.com/watch?v=DtTUPKKeU8c","https://www.youtube.com/watch?v=P__GsC98jPw","https://www.youtube.com/watch?v=NczoVKmb1xs","https://www.youtube.com/watch?v=7_OZ4Bsyipk","https://www.youtube.com/watch?v=DYjFU8zATdc","https://www.youtube.com/watch?v=ijsQkQwNKzs","https://www.youtube.com/watch?v=RwthMKGN99A","https://www.youtube.com/watch?v=wM5ShDIxgaQ","https://www.youtube.com/watch?v=WlKQsXvfcds","https://www.youtube.com/watch?v=TxBRICiy0KU","https://www.youtube.com/watch?v=mM40Rp0m5AA","https://www.youtube.com/watch?v=TSgrGqOIXGw","https://www.youtube.com/watch?v=RQIuDXJTGbc","https://www.youtube.com/watch?v=VezTFmabGWo","https://www.youtube.com/watch?v=2XdD_BJ5D18","https://www.youtube.com/watch?v=LvI4plyRcrs","https://www.youtube.com/watch?v=GMddfZCiiQ4","https://www.youtube.com/watch?v=cLgarIGTAe0","https://www.youtube.com/watch?v=OUzEUsNepC4","https://www.youtube.com/watch?v=yAksbBrYYsk","https://www.youtube.com/watch?v=ywdF8ixPCQ8","https://www.youtube.com/watch?v=cNoSHuF5mac","https://www.youtube.com/watch?v=OAbaZQPj97o","https://www.youtube.com/watch?v=4C2TRjy9oVQ","https://www.youtube.com/watch?v=D46urKgzDbY","https://www.youtube.com/watch?v=8B4tHaw6Hb4","https://www.youtube.com/watch?v=N4N5E0yp2EA","https://www.youtube.com/watch?v=_ygkBblLHTE","https://www.youtube.com/watch?v=GasAQC2TVcA","https://www.youtube.com/watch?v=G0S8teWZy3U","https://www.youtube.com/watch?v=DvlnYSvvqpU","https://www.youtube.com/watch?v=w_jO52l-8ok","https://www.youtube.com/watch?v=7Aqu9Mo42XQ","https://www.youtube.com/watch?v=1K6l7wIuOHg","https://www.youtube.com/watch?v=cY27XD0ZRho","https://www.youtube.com/watch?v=saDUi6_xQKU","https://www.youtube.com/watch?v=4tMn-cTP_wQ","https://www.youtube.com/watch?v=fAgo_BNUB_g","https://www.youtube.com/watch?v=OBcYr05W8Cs","https://www.youtube.com/watch?v=tva9Kl62-Ck","https://www.youtube.com/watch?v=BwkYStaZc_M","https://www.youtube.com/watch?v=gyXM70Ll5T4","https://www.youtube.com/watch?v=xkI9StSO9AM","https://www.youtube.com/watch?v=CWqSCn0SG10"]},"columns":[{"accessor":"title","name":"Title","type":"character"},{"accessor":"artist","name":"Artist","type":"character"},{"accessor":"review_date","name":"Review date","type":"Date"},{"accessor":"score","name":"Score","type":"numeric"},{"accessor":"word_score","name":"Word score/observation","type":"character"},{"accessor":"link","name":"Review link","type":"character"}],"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"highlight":true,"bordered":true,"dataKey":"f7118543975184b0e0e41cf2ff74d322","key":"f7118543975184b0e0e41cf2ff74d322"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="audio-features" class="section level2">
<h2>Audio features</h2>
<p>Later, I pulled the albums’ audio features in Python with <code>spotipy</code>. The code can be <a href="https://github.com/danielbrito91/blog/tree/main/content/post/2021-07-24-fantano-doesn-t-like-to-dance-a-classification-model-on-needle-drop-s-reviews/input">accessed here</a>. The following features were gathered, whose description can be found on <a href="https://hexdocs.pm/spotify_web_api/api-reference.html">Spotify Web API documentation</a>:</p>
<ul>
<li><p><code>explicity</code>: “whether or not the track has explicit lyrics (<code>true</code> = yes it does; <code>false</code> = no it does not OR unknown).”</p></li>
<li><p><code>acousticness</code>: “a confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic”</p></li>
<li><p><code>danceability</code>: “danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable”. <a href="https://twitter.com/_RCharlie">Charlie Thompson</a> made a great <a href="https://www.thompsonanalytics.com/blog/thom-yorke/">analysis of the danceability of Thom York’s music projects over time (Radiohead, solo albums, and Atoms for Peace)</a></p></li>
<li><p><code>track_duration</code>: “the duration of the track in milliseconds”</p></li>
<li><p><code>energy</code>: “energy is a measure from 0.0 to 1.0 and represents a perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. For example, death metal has high energy, while a Bach prelude scores low on the scale. Perceptual features contributing to this attribute include dynamic range, perceived loudness, timbre, onset rate, and general entropy”</p></li>
<li><p><code>instrumentalness</code>: “predicts whether a track contains no vocals. ‘Ooh’ and ‘aah’ sounds are treated as instrumental in this context. Rap or spoken word tracks are clearly ‘vocal’. The closer the instrumentalness value is to 1.0, the greater likelihood the track contains no vocal content. Values above 0.5 are intended to represent instrumental tracks, but confidence is higher as the value approaches 1.0.”</p></li>
<li><p><code>liveness</code>: “detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live. A value above 0.8 provides strong likelihood that the track is live”</p></li>
<li><p><code>loudness</code>: “the overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typical range between -60 and 0 db.”</p></li>
<li><p><code>speechiness</code>: “speechiness detects the presence of spoken words in a track. The more exclusively speech-like the recording (e.g. talk show, audio book, poetry), the closer to 1.0 the attribute value. Values above 0.66 describe tracks that are probably made entirely of spoken words. Values between 0.33 and 0.66 describe tracks that may contain both music and speech, either in sections or layered, including such cases as rap music. Values below 0.33 most likely represent music and other non-speech-like tracks”</p></li>
<li><p><code>tempo</code>: “the overall estimated tempo of a track in beats per minute (BPM).”</p></li>
<li><p><code>valence</code>: “a measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry).”</p></li>
</ul>
<p>I also got the album’s popularity (<code>album_popularity</code>, a value between 0 and 100, with 100 being the most popular) and the list of genres associated with the artist (<code>artist_genres</code>). The gathered data were stored on the <code>spotify_songs.csv</code> file (available on GitHub).</p>
<pre class="r"><code>songs &lt;- read.csv(&quot;input/spotify_songs.csv&quot;)</code></pre>
</div>
<div id="joining-all-together" class="section level2">
<h2>Joining all together</h2>
<p>Later, I joined the songs data with the reviews data, extracted the artist genres (1 genre per column). The mean and the standard deviation of each song’s audio feature were summarised by album. Also, I calculated the “Sonic Anger Index” of each album based on its mean energy and valence, following the approach by <a href="https://towardsdatascience.com/angriest-death-grips-data-anger-502168c1c2f0">Even Oppenheimer to find the angriest Death Grips song</a>.</p>
<pre class="r"><code>reviews_songs &lt;- reviews %&gt;%
        left_join(songs, by = c(&quot;album_id&quot;, &quot;album_uri&quot;)) %&gt;% 
  #removing the type of record (album, ep, ...), the album genres (it is empty) and track numbers from data
  select(-review_type, -album_type, -album_genres, -track_number) %&gt;%
  #extracting one genre per column
  mutate(genre = gsub(pattern = &quot;\\[&quot;, replacement = &quot;&quot;, artist_genres),
               genre = gsub(pattern = &quot;\\]&quot;, replacement = &quot;&quot;, genre),
               genre = gsub(pattern = &quot;\\&#39;&quot;, replacement = &quot;&quot;, genre),
               genre = str_split(genre, pattern = &quot;,&quot;)) %&gt;%
        unnest_wider(genre) %&gt;% 
        rename(genre_01 = ...1,
               genre_02 = ...2,
               genre_03 = ...3,
               genre_04 = ...4,
               genre_05 = ...5,
               song_name = name) %&gt;% 
        mutate_at(c(&quot;genre_01&quot;, &quot;genre_02&quot;, &quot;genre_03&quot;, &quot;genre_04&quot;, &quot;genre_05&quot;),
                  str_trim) %&gt;%
        mutate_at(c(&quot;genre_01&quot;, &quot;genre_02&quot;, &quot;genre_03&quot;, &quot;genre_04&quot;, &quot;genre_05&quot;),
                  ~str_replace(., &quot;^$&quot;, NA_character_)) %&gt;%
        mutate_at(c(&quot;genre_01&quot;, &quot;genre_02&quot;, &quot;genre_03&quot;, &quot;genre_04&quot;, &quot;genre_05&quot;),
                  ~str_replace(., &quot;\&quot;&quot;, NA_character_)) %&gt;% 
        select(album_id:genre_05, -artist_genres, -album)

#extract the mean and std. dev. of the songs features by album
songs_features_by_album &lt;-
  reviews_songs %&gt;%
    group_by(album_id) %&gt;%
        summarise(
                album_length = sum(track_duration_ms),
                mean_track_duration = mean(track_duration_ms, na.rm = TRUE),
                sd_track_duration = sd(track_duration_ms, na.rm = TRUE),
                mean_expl = mean(track_explicity, na.rm = TRUE),
                mean_acousticness = mean(acousticness, na.rm = TRUE),
                sd_acousticness = sd(acousticness, na.rm = TRUE),
                mean_danceability = mean(danceability, na.rm = TRUE),
                sd_danceability = sd(danceability, na.rm = TRUE),
                mean_energy = mean(energy, na.rm = TRUE),
                sd_energy = sd(energy, na.rm = TRUE),
                mean_instrumentalness = mean(instrumentalness, na.rm = TRUE),
                sd_instrumentalness = sd(instrumentalness, na.rm = TRUE),
                mean_liveness = mean(liveness, na.rm = TRUE),
                sd_liveness = sd(liveness, na.rm = TRUE),
                mean_loudness = mean(loudness, na.rm = TRUE),
                sd_loudness = sd(loudness, na.rm = TRUE),
                mean_speechiness = mean(speechiness, na.rm = TRUE),
                sd_speechiness = sd(speechiness, na.rm = TRUE),
                mean_tempo = mean(tempo, na.rm = TRUE),
                sd_tempo = sd(tempo, na.rm = TRUE),
                mean_valence = mean(valence, na.rm = TRUE),
                sd_valence = sd(valence, na.rm = TRUE)) %&gt;% 
  mutate(sonic_anger = sqrt((1 - mean_valence) * mean_energy),
        album_length_min = album_length / 60000) %&gt;% 
  select(-album_length)</code></pre>
<p>Finally, I selected the first valid value in the features that contained genres and consolidated the data in <code>album_review_features</code>.</p>
<pre class="r"><code>album_review_features &lt;-
  reviews_songs %&gt;% 
  select(album_id:album_popularity, genre_01:genre_05) %&gt;%
  distinct() %&gt;% 
  left_join(songs_features_by_album,
                  by = &quot;album_id&quot;) %&gt;% 
  mutate_at(c(&quot;genre_01&quot;, &quot;genre_02&quot;, &quot;genre_03&quot;, &quot;genre_04&quot;, &quot;genre_05&quot;),
                as.character) %&gt;% 
  mutate(genre = case_when(
    !is.na(genre_01) ~ genre_01,
    !is.na(genre_02) ~ genre_02,
    !is.na(genre_03) ~ genre_03,
    !is.na(genre_04) ~ genre_04,
    !is.na(genre_05) ~ genre_05,
    TRUE ~ NA_character_
        )) %&gt;%
  select(-genre_01, -genre_02, -genre_03, -genre_04, -genre_05)</code></pre>
<hr />
</div>
</div>
<div id="distribution-of-the-scores" class="section level1">
<h1>Distribution of the scores</h1>
<p>Not every album is blessed with a high score from Melon. The mean score was 6.33, with most of the albums getting a 7.</p>
<pre class="r"><code>palette &lt;- c(&quot;#fcf281&quot;, &quot;#011627&quot;, &quot;#ff3b3b&quot;, &quot;#AF4D98&quot;, &quot;#EFCFE3&quot;)

min_date &lt;- paste0(month(min(album_review_features$review_date),
                         label = TRUE,
                         locale = &#39;English_United States.1252&#39;),
                   &quot;/&quot;,
                   year(min(album_review_features$review_date)))

max_date &lt;- paste0(month(max(album_review_features$review_date),
                         label = TRUE,
                         locale = &#39;English_United States.1252&#39;),
                   &quot;/&quot;,
                   year(max(album_review_features$review_date)))
album_review_features %&gt;% 
        count(score) %&gt;%
        filter(!is.na(score)) %&gt;% 
        ggplot(aes(x = score, y = n)) +
        geom_col(aes(fill = score &gt;= 8), show.legend = FALSE) +
        scale_fill_manual(values = palette[c(2, 3)]) +
        scale_x_continuous(breaks=seq(0, 10)) +
        labs(title = glue(&quot;Numerical scores distribution: &lt;span style=&#39;color:#ff3b3b&#39;&gt;{round(100 * mean(album_review_features$score &gt;= 8, na.rm = TRUE))}% of loved albums&lt;/span&gt;&quot;),
             subtitle = glue(&quot;Reviews between {min_date} and {max_date}&quot;),
             y = &quot;Number of albums&quot;,
             x = &quot;&quot;) +
        theme_ipsum_tw(grid = &quot;Y&quot;) +
        theme(
                plot.background = element_rect(fill = palette[1]),
                plot.title = element_markdown()
        )</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Some of the albums didn’t receive a numeric score. They are summarised in the <code>word_score</code> attribute of our data. As shown below, the classics, quick reviews, NOT GOOD, co-review and lo-fitano fall into this category, as the <a href="https://www.youtube.com/watch?v=NXcbNP9i2jw">Cal Chuchesta throwing up on the Lady Gaga’s Born This Way review</a>.</p>
<p><img src="https://i.makeagif.com/media/4-29-2021/eHTyyw.gif" /></p>
<pre class="r"><code>album_review_features %&gt;%
    filter(!is.na(word_score)) %&gt;% 
    mutate(word_score =
             fct_lump_min(word_score, 3, other_level = &quot;others&quot;)
           ) %&gt;% 
    count(word_score, sort = TRUE) %&gt;%
    mutate(word_score =
             fct_reorder(word_score, n),
           ) %&gt;% 
    ggplot(aes(x = word_score, y = n, label = n)) +
    geom_col(fill = palette[2]) +
    geom_text(aes(x = word_score, y = n), family = &quot;Titillium Web&quot;,
              hjust = -.3) +
    labs(x = &quot;&quot;, y = &quot;&quot;,
         title = &quot;Reviews without a numerical score&quot;,
         subtitle =  glue(&quot;{album_review_features %&gt;% filter(!is.na(word_score)) %&gt;% nrow()} reviews didn&#39;t receive a numerical score&quot;)) +
    coord_flip() +
    theme_ipsum_tw(grid = &quot;&quot;) +
    theme(
        plot.background = element_rect(fill = palette[1]),
        axis.text.x = element_blank()
        )</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="preparing-the-data" class="section level1">
<h1>Preparing the Data</h1>
<div id="working-with-genres" class="section level2">
<h2>Working with genres</h2>
<p>We have 358 genres, of which the most common are alternative hip hop, alternative dance, art pop, alternative rock, and hip hop. That is a lot of different categories to work with.</p>
<p><img src="https://thumbs.gfycat.com/CloudyThisChick-size_restricted.gif" /></p>
<p>To deal with it, I replaced the specifics subgenres with a more broad view of the genres: instead of “alternative hip hop”, “hip hop”, “atl hip hop” and the variations that appear on the data, let’s just call it “hip hop”. The same idea was applied to rock, metal, punk, pop, folk, r&amp;b, electronic, regional music, experimental, jazz and ambient. Some of the subgenres were too specific (afrofuturism, escape room, chamber psych and permanent wave) and contained too many observations. They were replaced regarding the artists associated with them. <a href="https://rateyourmusic.com/genres">Rate Your Music</a> data was a major reference here.</p>
<pre class="r"><code>album_review_features %&gt;%
  count(genre, sort = TRUE) %&gt;% 
  reactable(highlight = TRUE)</code></pre>
<div id="htmlwidget-2" class="reactable html-widget" style="width:auto;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-2">{"x":{"tag":{"name":"Reactable","attribs":{"data":{"genre":["alternative hip hop","alternative dance","art pop",null,"alternative rock","hip hop","alternative metal","dance pop","atl hip hop","conscious hip hop","afrofuturism","alternative emo","alternative r&b","escape room","ambient","bass music","chillwave","freak folk","abstract hip hop","indie rock","atmospheric black metal","baroque pop","brooklyn indie","chicago rap","emo rap","pop","album rock","doom metal","art rock","australian indie","chaotic hardcore","alternative country","art punk","avant-garde metal","dark trap","downtempo","melodic rap","canadian hip hop","dance-punk","garage psych","chamber psych","dark jazz","detroit hip hop","east coast hip hop","indie pop","anti-folk","black metal","canadian contemporary r&b","death metal","modern rock","ai","alternative americana","alternative pop","ambient folk","american grindcore","chamber pop","gangster rap","psychedelic hip hop","boom bap","canadian pop","contemporary country","danish alternative rock","indie garage rock","modern alternative rock","rap","alt z","comedy rap","electropop","experimental hip hop","hard rock","mathcore","abstractro","atlanta indie","australian dance","black thrash","boy band","british soul","brutal death metal","bubblegrunge","canadian indie","canadian post-rock","crossover thrash","dream pop","edmonton indie","electronica","indie soul","latin","noise punk","permanent wave","abstract","ambient black metal","ambient techno","american post-rock","australian alternative rock","australian psych","avant-garde black metal","avant-garde jazz","black death","brighton indie","bristol indie","british post-rock","cali rap","deathgrind","drone","drone metal","emo","garage rock","hardcore punk","indie punk","k-pop","neo-psychedelic","nu gaze","post-doom metal","uk alternative pop","acoustic punk","afro psych","albuquerque indie","arkansas metal","australian garage punk","autonomous black metal","avant-rock","bedroom pop","bitpop","boston hardcore","boston indie","british jazz","britpop","brostep","calgary indie","canadian hardcore","chicano punk","colombian pop","contemporary jazz","dark clubbing","denver metal","dirty south rap","drill and bass","dutch indie rock","eau claire indie","electro","etherpop","g funk","gothenburg indie","grime","house","houston rap","indie folk","melodic metalcore","metalcore","noise rock","pennsylvania hardcore","pop rap","underground hip hop","wonky","acoustic rock","afrobeat","alabama indie","alabama rap","ambient house","atmospheric sludge","australian black metal","australian hip hop","baltimore indie","bass trap","bay area indie","big beat","birmingham grime","birmingham metal","black punk","black sludge","blackened crust","blackgaze","boston metal","boston rock","bow pop","bristol electronic","c86","canadian psychedelic rock","cavernous death metal","chicago indie","chicha","chill r&b","classic soul","colombian rock","cuban alternative","dance rock","death industrial","deconstructed club","denton tx indie","dfw rap","dmv rap","double drumming","dreamo","electronic rock","electronic trap","experimental","experimental folk","experimental indie","experimental pop","folk","french shoegaze","funk","garage pop","gauze pop","glitch pop","grave wave","indonesian hip hop","industrial noise","j-idol","london indie","melodic hardcore","metropopolis","miami hip hop","modern blues rock","north carolina hip hop","ohio hip hop","popgaze","progressive black metal","psychedelic soul","r&b en espanol","screamo","stomp and holler","synth punk","trap","uk hip hop","abstract idm","adult standards","albany ny indie","alternative pop rock","alternative roots rock","american choir","american shoegaze","arab pop","arabic jazz","arkansas country","asian american hip hop","atlanta metal","aussie emo","austindie","australian experimental","australian r&b","auteur-compositeur-interprete quebecois","balearic","barbadian pop","bassline","battle rap","belgian black metal","belgian experimental","bergen indie","blackened deathcore","blues","bmore","boston hip hop","brazilian experimental","brazilian indie","breakcore","british death metal","british industrial","british math rock","brooklyn drill","canadian death metal","canadian electronic","canadian latin","canadian metal","canadian punk","canadian singer-songwriter","candy pop","cartoon","chamber folk","chicago drill","chillhop","classic afrobeat","classic soundtrack","classical percussion","comedy rock","comic","comic metal","complextro","compositional ambient","cool jazz","country rap","country rock","cyberpunk","dark folk","dark post-punk","dc indie","deathcore","deep gothic post-punk","deep underground hip hop","derby indie","digital hardcore","downtempo bass","dreamgaze","dutch indie","early us punk","edm","el paso indie","electra","experimental jazz","experimental rock","finnish doom metal","florida rap","folk punk","folktronica","footwork","fourth world","french indie pop","future bass","future funk","gaian doom","gainesville indie","hard bass","hardcore hip hop","hardvapour","hauntology","hawaiian hip hop","horror synth","indie hip hop","instrumental math rock","instrumental rock","irish singer-songwriter","j-punk","j-rap","japanese alternative pop","jazz rap","k-indie","kentucky hip hop","kentucky metal","korean experimental","la pop","laboratorio","lo-fi emo","mashup","math rock","meme rap","memphis hip hop","miami metal","modern folk rock","modern power pop","new jersey rap","new wave of osdm","new york death metal","norwegian alternative rock","nyc rap","plunderphonics","pop punk","pop soul","popping","progressive jazz fusion","seattle indie","shimmer pop","soul flow","swedish indie pop","swedish singer-songwriter","swiss black metal","uk alternative hip hop","urbano espanol","wu fam"],"n":[177,136,135,122,116,56,50,50,46,38,37,35,34,33,28,28,28,28,24,21,20,19,19,18,18,18,16,16,15,15,15,14,13,13,13,12,12,11,11,11,10,10,10,10,10,9,9,9,9,9,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},"columns":[{"accessor":"genre","name":"genre","type":"character"},{"accessor":"n","name":"n","type":"numeric"}],"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"highlight":true,"dataKey":"1ede3c0f122e66de36c00f3a4dce0c3d","key":"1ede3c0f122e66de36c00f3a4dce0c3d"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>reviews_features_genres &lt;-
  album_review_features %&gt;%
  rename(&quot;subgenre&quot; = genre) %&gt;% 
  mutate(genre = case_when(
    #finding the genres based on the subgenres
    str_detect(subgenre, paste(c(&quot;hip hop&quot;, &quot; rap&quot;, &quot;^rap$&quot;, &quot; trap&quot;, &quot;^trap$&quot;,
                 &quot;boom bap&quot;, &quot;^g funk$&quot;, &quot;brooklyn drill&quot;, &quot;chicago drill&quot;, &quot;j-rap&quot;,
                 &quot;soul flow&quot;, &quot;urbano espanol&quot;, &quot;wu fam&quot;), collapse = &quot;|&quot;)) 
    ~ &quot;hip hop&quot;,
    str_detect(subgenre, paste(c(&quot;r&amp;b&quot;, &quot;afro psych&quot;, &quot;^funk$&quot;,
                                 &quot; soul&quot;, &quot;^blues$&quot;),
                               collapse = &quot;|&quot;))
    ~ &quot;r&amp;b&quot;,
    str_detect(subgenre, paste(c(&quot;pop&quot;, &quot;alt z&quot;, &quot;boy band&quot;, &quot;c86&quot;, &quot;j-idol&quot;,
                                 &quot;auteur-compositeur-interprete quebecois&quot;,
                                 &quot;swedish singer-songwriter&quot;,
                                 &quot;irish singer-songwriter&quot;), collapse = &quot;|&quot;))
    ~ &quot;pop&quot;,
    str_detect(subgenre, paste(c(&quot;metal&quot;, &quot;sludge&quot;, &quot;black&quot;, &quot;deathgrind&quot;,
                 &quot;deathcore&quot;, &quot;crossover thrash&quot;, &quot;gaian doom&quot;, &quot;new wave of osdm&quot;), collapse = &quot;|&quot;))
    ~ &quot;metal&quot;,
    str_detect(subgenre, paste(c(&quot;rock&quot;, &quot;garage psych&quot;,  &quot;neo-psychedelic&quot;, &quot; indie&quot;,
                 &quot;bubblegrunge&quot;, &quot;gaze&quot;, &quot;grave wave&quot;, &quot;austindie&quot;,
                 &quot;australian psych&quot;), collapse = &quot;|&quot;))
    ~ &quot;rock&quot;,
    str_detect(subgenre, paste(c(&quot;folk&quot;, &quot;stomp and holler&quot;,
                                 &quot;canadian singer-songwriter&quot;), collapse = &quot;|&quot;))
    ~ &quot;folk&quot;,
    str_detect(subgenre, paste(c(&quot;punk&quot;, &quot;hardcore&quot;, &quot; emo&quot;, &quot;^emo$&quot;,
                 &quot;grindcore&quot;, &quot;mathcore&quot;, &quot;screamo&quot;, &quot;dreamo&quot;), collapse = &quot;|&quot;))
    ~ &quot;punk&quot;,
    str_detect(subgenre, paste(c(&quot;jazz&quot;, &quot;adult standards&quot;), collapse = &quot;|&quot;)) ~ &quot;jazz&quot;,
    str_detect(subgenre, paste(c(&quot;chillwave&quot;, &quot;bass music&quot;, &quot;downtempo&quot;, &quot;electronica&quot;,
                 &quot;^ai$&quot;, &quot;abstract&quot;, &quot;australian dance&quot;, &quot;^future funk$&quot;,
                 &quot;ambient techno&quot;,  &quot;house&quot;, &quot;bass&quot;, &quot;elect&quot;, &quot;grime&quot;,
                 &quot;wonky&quot;, &quot;brostep&quot;, &quot;club&quot;,
                 &quot;big beat&quot;, &quot;chillhop&quot;, &quot;balearic&quot;, 
                 &quot;bmore&quot;, &quot;breakcore&quot;, &quot;complextro&quot;, &quot;edm&quot;, &quot;footwork&quot;,
                 &quot;hardvapour&quot;, &quot;horror synth&quot;), collapse = &quot;|&quot;))
    ~ &quot;electronic&quot;,
    str_detect(subgenre, paste(c(&quot; country&quot;, &quot;latin&quot;,
                                 &quot;alternative americana&quot;, &quot;afrobeat&quot;, &quot;chicha&quot;), collapse = &quot;|&quot;))
    ~ &quot;regional music&quot;,
    str_detect(subgenre, paste(c(&quot;industrial&quot;, &quot;drone&quot;, &quot;experimental&quot;,
                                 &quot;plunderphonics&quot;, &quot;laboratorio&quot;), collapse = &quot;|&quot;)) ~
      &quot;experimental&quot;,
    str_detect(subgenre, paste(c(&quot;hauntology&quot;, &quot; ambient&quot;), collapse = &quot;|&quot;)) ~
      &quot;ambient&quot;,
    #hardcoding genres of the subgenre afrofuturism 
    str_detect(artist, paste(c(&quot;Africa Hitech&quot;, &quot;Flying Lotus&quot;), collapse = &quot;|&quot;)) ~ &quot;electronic&quot;,
    str_detect(artist, paste(c(&quot;Alice Coltrane&quot;, &quot;Kamasi Washington&quot;,
                 &quot;Matana Roberts&quot;, &quot;Sons of Kemet&quot;), collapse = &quot;|&quot;)) ~ &quot;jazz&quot;,
    str_detect(artist, &quot;^FKA&quot;) ~ &quot;pop&quot;,
    str_detect(artist, paste(c(&quot;Moor Mother&quot;, &quot;Shabazz Palaces&quot;), collapse = &quot;|&quot;)) ~ &quot;hip hop&quot;,
    str_detect(artist, paste(c(&quot;Janelle Monáe&quot;, &quot;Kelela&quot;, &quot;Kevin Abstract&quot;,
                               &quot;Solange&quot;, &quot;Steve Lacy&quot;, &quot;THEESatisfaction&quot;,
                               &quot;Thundercat&quot;, &quot;Willow Smith&quot;), collapse = &quot;|&quot;)) ~ &quot;r&amp;b&quot;,
    #hardcoding genres of the subgenre escape room
    str_detect(artist, paste(c(&quot;100 gecs&quot;, &quot;Alice Glass&quot;, &quot;Clarence Clarity&quot;,
                               &quot;DJ Sabrina the Teenage DJ&quot;, &quot;^Salem$&quot;, 
                               &quot;Slauson Malone&quot;, &quot;^gupi$&quot;), collapse = &quot;|&quot;)) ~ &quot;electronic&quot;,
    str_detect(artist, paste(c(&quot;Anderson .Paak&quot;, &quot;^Boots$&quot;, &quot;ECCO2K&quot;,
                             &quot;^Jai Paul$&quot;, &quot;Kaytranada&quot;), collapse = &quot;|&quot;)) ~ &quot;r&amp;b&quot;,
    str_detect(artist, paste(c(&quot;Flatbush Zombies&quot;, &quot;^Heems$&quot;, &quot;^Lil B$&quot;,
                               &quot;Little Simz&quot;, &quot;Princess Nokia&quot;, &quot;Ratking&quot;), collapse = &quot;|&quot;)) ~ &quot;hip hop&quot;,
    str_detect(artist, &quot;Kero Kero Bonito&quot;) ~ &quot;pop&quot;,
    #hardcoding genres of the subgenre chamber psych
    str_detect(artist, paste(c(&quot;Fontaines D.C.&quot;, &quot;Protomartyr&quot;, &quot;^Shame$&quot;,
                               &quot;Sleaford Mods&quot;), collapse = &quot;|&quot;)) ~ &quot;punk&quot;,
    str_detect(artist, &quot;Ghostpoet&quot;) ~ &quot;electronic&quot;,
    #hardcoding genres of the subgenre permanent wave
    str_detect(artist, &quot;Green Day&quot;) ~ &quot;punk&quot;,
    str_detect(artist, &quot;Coldplay&quot;) ~ &quot;pop&quot;,
    
    TRUE ~ subgenre)) %&gt;% 
  mutate(genre = fct_lump_min(genre, 3, other_level = &quot;not found&quot;))</code></pre>
<p>Most of the reviewed albums fall into the hip hop genre, followed by rock, pop, metal, electronic, punk and alternative dance. Goodbye wu fam, plunderphonics and meme rap.</p>
<pre class="r"><code>reviews_features_genres %&gt;%
  mutate(genre = as.character(genre),
         genre = case_when(
    is.na(genre)~ &quot;genre or subgenre not found&quot;,
    genre == &quot;not found&quot; ~ &quot;genre or subgenre not found&quot;,
    TRUE ~ genre)) %&gt;% 
  count(genre, sort = T) %&gt;%
  ggplot(aes(x =reorder(genre, n), y = n)) +
  geom_col(aes(fill = (genre == &quot;hip hop&quot;),
               alpha = (genre == &quot;genre or subgenre not found&quot;)), show.legend = FALSE) +
  geom_text(aes(label = n,
                alpha = (genre == &quot;genre or subgenre not found&quot;),
                col = (genre == &quot;hip hop&quot;)),
            hjust = -.3, show.legend = FALSE,
            family = &quot;Titillium Web Light&quot;) +
  scale_alpha_manual(values = c(1, .3)) +
  scale_fill_manual(values = c(palette[2], palette[3])) +
  scale_color_manual(values = c(palette[2], palette[3])) +
  coord_flip() +
  labs(title = &quot;&lt;span style=&#39;color:#ff3b3b&#39;&gt;**Hip hop**&lt;/span&gt; is the most reviewed genre&quot;,
       x = &quot;&quot;,
       y = &quot;&quot;) +
  ylim(c(0,580)) +
  theme_ipsum_tw(grid = &quot;&quot;) +
  theme(
        plot.background = element_rect(fill = palette[1]),
        axis.text.x = element_blank(),
        plot.title = element_markdown())</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/genre_view-1.png" width="672" /></p>
</div>
<div id="dealing-with-missing-albums-and-scores" class="section level2">
<h2>Dealing with missing albums and scores</h2>
<p>Albums without numerical scores and the albums that I didn’t find on Spotify weren’t considered. So, filtering that data, we have a total of 2097 albums to create our predictors, target and labels.</p>
<pre class="r"><code>na_rm_data &lt;- 
  reviews_features_genres %&gt;%
  filter(!is.na(score), !is.na(album_uri)) %&gt;% 
  mutate(loved = 1*(score &gt;= 8),
         artist = str_replace(artist,
                              pattern = &quot;Kirin J Callinan&quot;,
                              replacement = &quot;Kirin J. Callinan&quot;),
         genre = fct_lump_min(genre, 50, other_level = &quot;others&quot;),
         genre = as.character(genre),
         genre = case_when(
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;Wild Flag&quot;, &quot;The Debauchees&quot;,
                                              &quot;Snake Oil&quot;, &quot;Little Women&quot;,
                                              &quot;Jesu, Sun Kil Moon&quot;, &quot;Guardian Alien&quot;,
                                              &quot;Dweller On the Threshold&quot;, &quot;Andrew W.K.&quot;), collapse = &quot;|&quot;))
    ~ &quot;rock&quot;,
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;Ty Segall Band&quot;, &quot;Soupcans&quot;,
                                              &quot;OFF!&quot;, &quot;lobsterfight&quot;, &quot;Hoax&quot;,
                                              &quot;Haunted Horses&quot;, &quot;Calvaiire&quot;), collapse = &quot;|&quot;))
    ~ &quot;punk&quot;,
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;The Log.Os&quot;, &quot;Lee Bannon&quot;,
                                              &quot;H-SIK&quot;, &quot;Evian Christ&quot;, &quot;Arca&quot;), collapse = &quot;|&quot;))
    ~ &quot;electronic&quot;, 
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;The Act of Estimating as Worthless&quot;,
                                              &quot;Phoebe Bridgers&quot;), collapse = &quot;|&quot;))
    ~ &quot;folk&quot;, 
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;Red Horse&quot;, &quot;Otis Brown III&quot;, &quot;Okonkolo&quot;), collapse = &quot;|&quot;))
    ~ &quot;others&quot;, 
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;Magic Kids&quot;, &quot;Kirin J. Callinan&quot;,
                                              &quot;Jonathan Rado&quot;, &quot;Hayley Williams&quot;), collapse = &quot;|&quot;))
    ~ &quot;pop&quot;, 
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;Spirit Possession&quot;, &quot;Sisu&quot;, &quot;Lycus&quot;), collapse = &quot;|&quot;))
    ~ &quot;metal&quot;,
    is.na(genre) &amp; str_detect(artist, paste(c(&quot;Sisyphus&quot;, &quot;Rural Internet&quot;,
                                              &quot;Mr. Yote&quot;, &quot;Future&quot;, &quot;93PUNX, Vic Mensa&quot;), collapse = &quot;|&quot;))
    ~ &quot;hip hop&quot;,
    TRUE ~ genre
  ))

predictors &lt;-
  na_rm_data %&gt;%
  select(genre, album_length_min, mean_track_duration:sonic_anger)

target &lt;-
        na_rm_data %&gt;% 
        select(loved)

labels &lt;-
        na_rm_data %&gt;% 
        select(album_id, album_uri, title, artist, genre, score)</code></pre>
</div>
<div id="splitting-the-data" class="section level2">
<h2>Splitting the data</h2>
<p>Let’s go to Python to preprocess the data using Scikit-Learn. First, the data was imported into the Python environment. The train/test splitting was stratifying by the score values, considering that we have few observations with very low (0-3) and very high (9-10) scores.</p>
<pre class="python"><code>from sklearn.model_selection import train_test_split

X = r.predictors
y = r.target

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, stratify=y, random_state=42)

y_train_values = y_train.values.ravel() #array of values
y_test_values = y_test.values.ravel()</code></pre>
</div>
<div id="scaling-and-encoding" class="section level2">
<h2>Scaling and encoding</h2>
<p>I preprocessed the train data first to avoid data leakage (see, for instance, the <a href="https://towardsdatascience.com/6-sklearn-mistakes-that-silently-tell-you-are-a-rookie-84fa55f2b9dd">Bex T. post on Towards Data Science</a>). The missing numeric features were imputed with the median values. The categorical features were encoded with One Hot Encoder, and the numerical features were scaled with the standard scaler.</p>
<pre class="python"><code>from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline
import pandas as pd
import numpy as np

X_train = X_train.fillna(np.nan)

num_attribs = list(X_train.drop(columns = [&quot;genre&quot;]))
cat_attribs = [&quot;genre&quot;]

num_pipeline = Pipeline([
    (&quot;imputer&quot;, SimpleImputer(strategy = &quot;median&quot;, missing_values=np.nan)),
    (&quot;std_scaler&quot;, StandardScaler())
])

cat_pipeline = Pipeline([
    (&quot;one_hot&quot;, OneHotEncoder())
])

full_pipeline = ColumnTransformer([
    (&quot;num&quot;, num_pipeline, num_attribs),
    (&quot;cat&quot;, cat_pipeline, cat_attribs)
])

X_train_prep = full_pipeline.fit_transform(X_train)</code></pre>
<hr />
</div>
</div>
<div id="supervised-learning-modeling" class="section level1">
<h1>Supervised Learning Modeling</h1>
<p>The data is quite unbalanced. If we measure our success with accuracy, a dummy model that considers that Fantano didn’t love any album would get a 74% score on train data. But who wants such a sad world with no loved albums? So, I trained a classification model looking for optimizing the total Area Under the Curve (AUC) metric, trying to find a classifier that shows if Melon would love an album.</p>
<p>{{% tweet "1404171016616628228" %}}</p>
<div id="dummy-predictor" class="section level2">
<h2>Dummy predictor</h2>
<p>As a base estimator, let’s create a classifier that considers that Fantano doesn’t love any album, which results in an AUC score of 0.5. Our goal is to find something better than that.</p>
<pre class="python"><code>from sklearn.metrics import confusion_matrix
from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
from sklearn.dummy import DummyClassifier

dummy_clf = DummyClassifier(strategy=&quot;most_frequent&quot;)
dummy_clf.fit(X_train_prep, y_train_values)</code></pre>
<pre><code>## DummyClassifier(strategy=&#39;most_frequent&#39;)</code></pre>
<pre class="python"><code>dummy_pred = dummy_clf.predict(X_train)

dummy_roc_auc = roc_auc_score(y_train_values, dummy_pred)
confusion_matrix(y_train_values, dummy_pred)</code></pre>
<pre><code>## array([[1237,    0],
##        [ 440,    0]], dtype=int64)</code></pre>
</div>
<div id="random-forest" class="section level2">
<h2>Random Forest</h2>
<p>Due to the considerable number of predictors and complexity of the task, I focused on ensemble learning algorithms. I started with a Random Forest Classifier - the popular ensemble of Decisions Trees. For hyperparameter tuning, I applied <code>RandomSearchCV</code>, tunning the minimum number of samples in each node before splitting (<code>min_samples_split</code>), the minimum number of samples in each leaf (<code>min_samples_leaf</code>) and the maximum number of features evaluated for each splitting (<code>max_features</code>). The ranges of values for tunning the parameters were selected after running the randomized search a couple of times.</p>
<pre class="python"><code>from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import RandomizedSearchCV

rf_clf = RandomForestClassifier(random_state = 42, n_estimators=500)
rf_params = {&quot;min_samples_split&quot;: np.linspace(2, 30, num = 29).astype(int),
            &quot;min_samples_leaf&quot;: np.linspace(1, 10, num = 10).astype(int),
            &quot;max_features&quot;: [&quot;log2&quot;, &quot;sqrt&quot;]}

rf_rscv = RandomizedSearchCV(rf_clf, rf_params, cv=3,return_train_score=True, scoring = &quot;roc_auc&quot;)
rf_rscv.fit(X_train_prep, y_train_values)</code></pre>
<pre><code>## RandomizedSearchCV(cv=3,
##                    estimator=RandomForestClassifier(n_estimators=500,
##                                                     random_state=42),
##                    param_distributions={&#39;max_features&#39;: [&#39;log2&#39;, &#39;sqrt&#39;],
##                                         &#39;min_samples_leaf&#39;: array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10]),
##                                         &#39;min_samples_split&#39;: array([ 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
##        19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])},
##                    return_train_score=True, scoring=&#39;roc_auc&#39;)</code></pre>
<pre class="python"><code>rfc = rf_rscv.best_estimator_</code></pre>
<p>We can see that precision falls quickly. It is far from the perfect classifier, but it shows some improvement compared to the baseline classifier. With a threshold of 0.2, we get close to 80% of the loved albums with precision near 30%. With a threshold of 0.5, almost no loved album would be identified.</p>
<pre class="python"><code>from sklearn.model_selection import cross_val_predict
from sklearn.metrics import precision_recall_curve
import matplotlib
import matplotlib.pyplot as plt

def plot_rec_prec(trained_model, plot_title):
  y_scores = cross_val_predict(trained_model, X_train_prep, y_train_values, cv = 3, method = &quot;predict_proba&quot;)
  precisions, recalls, thresholds = precision_recall_curve(y_train_values, y_scores[:,1])
  
  plt.subplot(1, 2, 1)
  plt.plot(recalls, precisions)
  plt.grid(True)
  plt.xlabel(&quot;Recall&quot;)
  plt.ylabel(&quot;Precision&quot;)
  plt.title(plot_title)
  plt.xticks(np.arange(0, 1.01, step=0.1))
  plt.yticks(np.arange(0, 1.01, step=0.1))
  
  plt.subplot(1, 2, 2)
  plt.grid(True)
  plt.plot(thresholds, precisions[:-1], &quot;b--&quot;, label = &quot;Precision&quot;)
  plt.plot(thresholds, recalls[:-1], &quot;g-&quot;, label =&quot;Recall&quot;)
  plt.xlabel(&quot;Threshold&quot;)
  plt.yticks(np.arange(0, 1.01, step=0.1))
  plt.legend()</code></pre>
<pre class="python"><code>plt.close()
plot_rec_prec(rfc, &quot;Random Forest: precision and recall&quot;)
plt.show()</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/split-2.png" width="672" /></p>
<pre class="python"><code>from sklearn.model_selection import cross_val_score

rf_scores = cross_val_score(rfc, X_train_prep, y_train_values, scoring = &quot;roc_auc&quot;, cv=10)</code></pre>
</div>
<div id="extremely-randomized-trees" class="section level2">
<h2>Extremely Randomized Trees</h2>
<p>The Extremely Randomized Trees (or Extra-trees) model makes the Random Forest more random by using random thresholds for each feature. I thought about giving it a try, checking if a higher randomization level could improve the results. I also performed hyperparameter tunning in <code>min_samples_split</code>, <code>min_samples_leaf</code> and <code>max_features</code>.</p>
<pre class="python"><code>from sklearn.ensemble import ExtraTreesClassifier

et_clf = ExtraTreesClassifier(random_state = 42, n_estimators=500)

et_params = [
    {&quot;min_samples_split&quot;: np.linspace(2, 30, num=29).astype(int),
    &quot;min_samples_leaf&quot;: np.linspace(1, 10, num = 10).astype(int),
    &quot;max_features&quot;: [&quot;log2&quot;, &quot;sqrt&quot;]}]
    
et_rscv = RandomizedSearchCV(et_clf, et_params, cv=3, return_train_score=True, scoring = &quot;roc_auc&quot;)
et_rscv.fit(X_train_prep, y_train_values)</code></pre>
<pre><code>## RandomizedSearchCV(cv=3,
##                    estimator=ExtraTreesClassifier(n_estimators=500,
##                                                   random_state=42),
##                    param_distributions=[{&#39;max_features&#39;: [&#39;log2&#39;, &#39;sqrt&#39;],
##                                          &#39;min_samples_leaf&#39;: array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10]),
##                                          &#39;min_samples_split&#39;: array([ 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
##        19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])}],
##                    return_train_score=True, scoring=&#39;roc_auc&#39;)</code></pre>
<pre class="python"><code>etc = et_rscv.best_estimator_</code></pre>
<p>The precision and recall plots are pretty like the ones on Random Forest, although the results seem slightly better – i.e., for a threshold of 0.2, we got a recall near .85.</p>
<pre class="python"><code>plt.close()
plot_rec_prec(etc, &quot;Extra-Tree: precision and recall&quot;)
plt.show()</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/split-4.png" width="672" /></p>
<pre class="python"><code>et_scores = cross_val_score(etc, X_train_prep, y_train_values, scoring=&quot;roc_auc&quot;,cv=10)</code></pre>
</div>
<div id="logistic-regression" class="section level2">
<h2>Logistic Regression</h2>
<p>This is the simplest model to use and interpret in this post. I fitted a logistic regression model using a ridge regularization (setting <code>penalty = “l2”</code>), and tunned the inverse of regularization strength (<code>C</code>) hyperparameter.</p>
<pre class="python"><code>from sklearn.linear_model import LogisticRegression

logit_clf= LogisticRegression(random_state=42, penalty=&quot;l2&quot;, solver=&quot;liblinear&quot;)

logit_costs = [{&quot;C&quot;: np.geomspace(1e-4, 1e1, 20)}]

logit = RandomizedSearchCV(logit_clf, logit_costs, cv=3, return_train_score=True, scoring = &quot;roc_auc&quot;)

logit.fit(X_train_prep, y_train_values)</code></pre>
<pre><code>## RandomizedSearchCV(cv=3,
##                    estimator=LogisticRegression(random_state=42,
##                                                 solver=&#39;liblinear&#39;),
##                    param_distributions=[{&#39;C&#39;: array([1.00000000e-04, 1.83298071e-04, 3.35981829e-04, 6.15848211e-04,
##        1.12883789e-03, 2.06913808e-03, 3.79269019e-03, 6.95192796e-03,
##        1.27427499e-02, 2.33572147e-02, 4.28133240e-02, 7.84759970e-02,
##        1.43844989e-01, 2.63665090e-01, 4.83293024e-01, 8.85866790e-01,
##        1.62377674e+00, 2.97635144e+00, 5.45559478e+00, 1.00000000e+01])}],
##                    return_train_score=True, scoring=&#39;roc_auc&#39;)</code></pre>
<pre class="python"><code>logit_best = logit.best_estimator_</code></pre>
<p>The precision-recall plots are not like the previous ones. With high thresholds (&gt;0.8), none album is identified as loved. Also, the precision-recall curve show some bouncing near recall = 0. The results seem slightly worse than the ensemble models.</p>
<pre class="python"><code>plt.close()

plot_rec_prec(logit_best, &quot;Logistic Regression: precision and recall&quot;)
plt.show()</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/split-6.png" width="672" /></p>
<pre class="python"><code>log_reg_scores = cross_val_score(logit_best, X_train_prep, y_train_values, scoring=&quot;roc_auc&quot;, cv=10)</code></pre>
</div>
<div id="comparing-the-models" class="section level2">
<h2>Comparing the models</h2>
<p>The models beat the dummy regressor, but not by an enormous difference. Extra-trees and random forest seem to outperform the logistic regression model. It looks like the extra-tree model got an AUC score slightly greater than the Random Forest.</p>
<pre class="r"><code>modeling_roc_auc &lt;-
    tibble(
           extra_tree = py$et_scores,
           random_forest = py$rf_scores,
           log_reg = py$log_reg_scores) %&gt;% 
    pivot_longer(cols = c(&quot;extra_tree&quot;, &quot;random_forest&quot;, &quot;log_reg&quot;)) %&gt;% 
    mutate(name = as.factor(name),
           name = fct_recode(name,
               &quot;Extra-Trees&quot; = &quot;extra_tree&quot;,
               &quot;Random Forest&quot; = &quot;random_forest&quot;,
               &quot;Log. Reg.&quot; = &quot;log_reg&quot;
           ))  %&gt;% 
    rename(Model = name)

modeling_roc_auc %&gt;% 
    ggplot(aes(x = Model, y = value)) +
    stat_halfeye(alpha = 0.4, fill=palette[3], point_alpha = 1, size = 2) +
    geom_point(shape=95, size = 2) +
    geom_hline(yintercept =  py$dummy_roc_auc, size = 1, lty = 2) +
    labs(title = &quot;10-fold Cross Validation ROC-AUC&quot;,
         subtitle = &quot;Model performance compared with the dummy ROC-AUC&quot;,
         y = &quot;&quot;,
         x = &quot;&quot;) +
        theme_ipsum_tw(grid = &quot;&quot;) +
        theme(
                plot.background = element_rect(fill = palette[1])
        )</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-6-8.png" width="672" /></p>
<hr />
</div>
</div>
<div id="predicting-and-evaluating-the-data" class="section level1">
<h1>Predicting and evaluating the data</h1>
<p>With the trained model, we can try to predict if an album is loved by Fantano. I transformed the test data using the full pipeline used in the training data, predicted the probability of an album being loved, and calculated the AUC score.</p>
<pre class="python"><code>#preprocess the test data
X_test_prep = full_pipeline.transform(X_test)

#predict the probability of the album get a high score with the Extra-tree model
y_pred_proba = etc.predict_proba(X_test_prep)

#AUC score
test_roc_auc = roc_auc_score(y_test_values, y_pred_proba[:, 1])

#False positive rate, true positive rate and thresholds
fpr, tpr, thresholds = roc_curve(y_test_values, y_pred_proba[:,1])</code></pre>
<p>The selected model achieved an AUC score of 0.6267, better than the dummy predictor and similar to the value found on the train set with cross-validation. It’s a quite limited classifier, but it can help distinguish the loved albums to some extent.</p>
<pre class="r"><code>tibble(fpr = py$fpr, tpr = py$tpr, thresholds = py$thresholds) %&gt;% 
  ggplot(aes(x = fpr, y = tpr)) +
  geom_line(size = 1) +
  geom_abline(slope = 1, lty = 2) +
  labs(title = glue(&quot;ROC curve: AUC = {round(py$test_roc_auc, 4)}&quot;),
       subtitle = &quot;Extra-tree model on test data&quot;,
       y = &quot;True Positive Rate (Recall)&quot;,
       x = &quot;False Positive Rate&quot;) +
  theme_ipsum_tw(grid = &quot;XY&quot;) +
  theme(
    plot.background = element_rect(fill = palette[1])
        )</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/roc_auc%20curve-1.png" width="672" /></p>
<pre class="python"><code>cat_encoder = full_pipeline.named_transformers_[&#39;cat&#39;]
cat_one_hot_attribs = list(cat_encoder[&#39;one_hot&#39;].categories_[0])
attributes = num_attribs + cat_one_hot_attribs</code></pre>
<p>The mean danceability of the album, standard deviation of its liveness, the standard deviation of its energy, and mean instrumentalness are the most important features of the model. To evaluate how they influence the data, let’s do a Partial Dependence Plot (PDP).</p>
<pre class="r"><code>feat_importance &lt;- tibble(importance = py$etc$feature_importances_,
                          feature = py$attributes) %&gt;% 
  arrange(desc(importance))

feat_importance %&gt;% 
  ggplot(aes(x = reorder(feature, importance), y =importance )) +
  geom_col(aes(
    fill = (feature %in% (head(feature, 4)))
    ), show.legend = FALSE) +
  scale_fill_manual(values = palette[c(4, 5)]) +
  coord_flip() +
  labs(x = &quot;&quot;,
       y = &quot;&quot;,
       title = &quot;Feature importance&quot;) +
   theme_ipsum_tw(grid = &quot;X&quot;) +
   theme(
     plot.background = element_rect(fill = palette[1]))</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>We see that, on average, increasing mean danceability of an album drops the chances of an album being loved. Also, increasing the standard deviation of liveness, the standard deviation of energy, and mean instrumentalness increase the chances of Fantano loving an album.</p>
<pre class="python"><code>from sklearn.inspection import plot_partial_dependence

train_prep_df = pd.DataFrame(X_train_prep)

train_prep_df.columns = attributes

plt.close()
display = plot_partial_dependence(etc, train_prep_df, features = [&#39;mean_danceability&#39;, &#39;sd_liveness&#39;, &#39;sd_energy&#39;, &#39;mean_instrumentalness&#39;])
display.figure_.subplots_adjust(wspace=0.4, hspace=0.3)
plt.show(display.figure_)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/split-1.png" width="672" /></p>
<p>I wanted to check how the mean danceability of an album affected the dependence of the prediction for each instance. So, I plotted the individual conditional expectation (ICE) curve. I couldn’t obtain the ICE curve values with <code>reticulate</code>, so I got it with Jupyter Notebook. The ICE plot shows that mean danceability doesn’t markedly influence the predicted values for some albums with a higher probability of being loved. But, although with some noise, the plot reveals a decreasing predicted chance of getting a high score when increasing the mean danceability.</p>
<pre class="r"><code>pdp_individual &lt;- read.csv(&quot;./input/pdp.csv&quot;)

pdp &lt;-
  tibble(pdp_individual) %&gt;% 
  pivot_longer(!val,
               names_to = &quot;sample&quot;,
               values_to = &quot;partial&quot;)

pdp_mean &lt;- pdp %&gt;%
  group_by(val) %&gt;% 
  summarise(partial_mean = mean(partial))

ggplot(data = pdp, mapping = aes(x = val, y = partial)) +
  geom_line(mapping = aes(group = sample), alpha = .1, col = palette[5]) +
  geom_line(data = pdp_mean, mapping = aes(x = val, y = partial_mean), col = palette[4], size = 2) +
  geom_text(aes(x = 0.5, y = 0.4, label = &quot;Mean value&quot;), col = palette[4],
            family = &quot;Titillium Web&quot;) +
  geom_curve(aes(x = 1, xend = 1.5, y = 0.4, yend = 0.28),
             arrow = arrow(length = unit(0.07, &quot;inch&quot;)), size = 0.4,
             curvature = -0.5, col = palette[4]) +
  labs(title = &quot;Mean danceability&quot;,
       x = &quot;mean_danceability&quot;,
       y = &quot;Partial depedence&quot;) +
  coord_fixed(ratio = 4.5) +
  theme_ipsum_tw(grid = &quot;XxYy&quot;) +
  theme(
    plot.background = element_rect(fill = palette[1]),
    plot.title = element_markdown()
  )</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-10-3.png" width="672" /></p>
<hr />
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>I fitted a classification model on the Needle Drop scores using the Spotify data as predictors. As a real-world model, it is a limited classifier. So, although Anthony will not be replaced by a machine (at least not yet), the data showed some interesting insights about what is going on in Melon’s head. And yeap, Fantano does not like to dance.</p>
<hr />
<p>tran…SITION</p>
<p>Thanks for reading! I’m open to any feedback or constructive criticism. You can reach me on Twitter <span class="citation">@_danielbrito_</span></p>
</div>
